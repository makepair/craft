// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft.proto

#ifndef PROTOBUF_raft_2eproto__INCLUDED
#define PROTOBUF_raft_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_raft_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestVoteRequestImpl();
void InitDefaultsRequestVoteRequest();
void InitDefaultsRequestVoteResponseImpl();
void InitDefaultsRequestVoteResponse();
void InitDefaultsLogEntryImpl();
void InitDefaultsLogEntry();
void InitDefaultsAppendEntriesRequestImpl();
void InitDefaultsAppendEntriesRequest();
void InitDefaultsAppendEntriesResponseImpl();
void InitDefaultsAppendEntriesResponse();
void InitDefaultsLockRequestImpl();
void InitDefaultsLockRequest();
void InitDefaultsLockResponseImpl();
void InitDefaultsLockResponse();
void InitDefaultsUnlockRequestImpl();
void InitDefaultsUnlockRequest();
void InitDefaultsUnlockResponseImpl();
void InitDefaultsUnlockResponse();
inline void InitDefaults() {
  InitDefaultsRequestVoteRequest();
  InitDefaultsRequestVoteResponse();
  InitDefaultsLogEntry();
  InitDefaultsAppendEntriesRequest();
  InitDefaultsAppendEntriesResponse();
  InitDefaultsLockRequest();
  InitDefaultsLockResponse();
  InitDefaultsUnlockRequest();
  InitDefaultsUnlockResponse();
}
}  // namespace protobuf_raft_2eproto
namespace craft {
class AppendEntriesRequest;
class AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesResponse;
class AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class LockRequest;
class LockRequestDefaultTypeInternal;
extern LockRequestDefaultTypeInternal _LockRequest_default_instance_;
class LockResponse;
class LockResponseDefaultTypeInternal;
extern LockResponseDefaultTypeInternal _LockResponse_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class RequestVoteRequest;
class RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
class RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class UnlockRequest;
class UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
class UnlockResponse;
class UnlockResponseDefaultTypeInternal;
extern UnlockResponseDefaultTypeInternal _UnlockResponse_default_instance_;
}  // namespace craft
namespace craft {

enum LogEntry_LogEntryType {
  LogEntry_LogEntryType_kUnknown = 0,
  LogEntry_LogEntryType_kNOOP = 1,
  LogEntry_LogEntryType_kData = 2,
  LogEntry_LogEntryType_kLock = 3,
  LogEntry_LogEntryType_kUnlock = 4
};
bool LogEntry_LogEntryType_IsValid(int value);
const LogEntry_LogEntryType LogEntry_LogEntryType_LogEntryType_MIN = LogEntry_LogEntryType_kUnknown;
const LogEntry_LogEntryType LogEntry_LogEntryType_LogEntryType_MAX = LogEntry_LogEntryType_kUnlock;
const int LogEntry_LogEntryType_LogEntryType_ARRAYSIZE = LogEntry_LogEntryType_LogEntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogEntry_LogEntryType_descriptor();
inline const ::std::string& LogEntry_LogEntryType_Name(LogEntry_LogEntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogEntry_LogEntryType_descriptor(), value);
}
inline bool LogEntry_LogEntryType_Parse(
    const ::std::string& name, LogEntry_LogEntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_LogEntryType>(
    LogEntry_LogEntryType_descriptor(), name, value);
}
// ===================================================================

class RequestVoteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.RequestVoteRequest) */ {
 public:
  RequestVoteRequest();
  virtual ~RequestVoteRequest();

  RequestVoteRequest(const RequestVoteRequest& from);

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestVoteRequest* other);
  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestVoteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestVoteRequest& from);
  void MergeFrom(const RequestVoteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestVoteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string server_id = 1;
  bool has_server_id() const;
  void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  const ::std::string& server_id() const;
  void set_server_id(const ::std::string& value);
  #if LANG_CXX11
  void set_server_id(::std::string&& value);
  #endif
  void set_server_id(const char* value);
  void set_server_id(const char* value, size_t size);
  ::std::string* mutable_server_id();
  ::std::string* release_server_id();
  void set_allocated_server_id(::std::string* server_id);

  // required string peer_id = 2;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_id(::std::string&& value);
  #endif
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // required int64 term = 3;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 3;
  ::google::protobuf::int64 term() const;
  void set_term(::google::protobuf::int64 value);

  // required int64 last_log_term = 4;
  bool has_last_log_term() const;
  void clear_last_log_term();
  static const int kLastLogTermFieldNumber = 4;
  ::google::protobuf::int64 last_log_term() const;
  void set_last_log_term(::google::protobuf::int64 value);

  // required int64 last_log_index = 5;
  bool has_last_log_index() const;
  void clear_last_log_index();
  static const int kLastLogIndexFieldNumber = 5;
  ::google::protobuf::int64 last_log_index() const;
  void set_last_log_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:craft.RequestVoteRequest)
 private:
  void set_has_server_id();
  void clear_has_server_id();
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_term();
  void clear_has_term();
  void set_has_last_log_term();
  void clear_has_last_log_term();
  void set_has_last_log_index();
  void clear_has_last_log_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr server_id_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::int64 term_;
  ::google::protobuf::int64 last_log_term_;
  ::google::protobuf::int64 last_log_index_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsRequestVoteRequestImpl();
};
// -------------------------------------------------------------------

class RequestVoteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.RequestVoteResponse) */ {
 public:
  RequestVoteResponse();
  virtual ~RequestVoteResponse();

  RequestVoteResponse(const RequestVoteResponse& from);

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RequestVoteResponse* other);
  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestVoteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestVoteResponse& from);
  void MergeFrom(const RequestVoteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestVoteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int64 term() const;
  void set_term(::google::protobuf::int64 value);

  // required bool granted = 2;
  bool has_granted() const;
  void clear_granted();
  static const int kGrantedFieldNumber = 2;
  bool granted() const;
  void set_granted(bool value);

  // @@protoc_insertion_point(class_scope:craft.RequestVoteResponse)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_granted();
  void clear_has_granted();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 term_;
  bool granted_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsRequestVoteResponseImpl();
};
// -------------------------------------------------------------------

class LogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  LogEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LogEntry_LogEntryType LogEntryType;
  static const LogEntryType kUnknown =
    LogEntry_LogEntryType_kUnknown;
  static const LogEntryType kNOOP =
    LogEntry_LogEntryType_kNOOP;
  static const LogEntryType kData =
    LogEntry_LogEntryType_kData;
  static const LogEntryType kLock =
    LogEntry_LogEntryType_kLock;
  static const LogEntryType kUnlock =
    LogEntry_LogEntryType_kUnlock;
  static inline bool LogEntryType_IsValid(int value) {
    return LogEntry_LogEntryType_IsValid(value);
  }
  static const LogEntryType LogEntryType_MIN =
    LogEntry_LogEntryType_LogEntryType_MIN;
  static const LogEntryType LogEntryType_MAX =
    LogEntry_LogEntryType_LogEntryType_MAX;
  static const int LogEntryType_ARRAYSIZE =
    LogEntry_LogEntryType_LogEntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LogEntryType_descriptor() {
    return LogEntry_LogEntryType_descriptor();
  }
  static inline const ::std::string& LogEntryType_Name(LogEntryType value) {
    return LogEntry_LogEntryType_Name(value);
  }
  static inline bool LogEntryType_Parse(const ::std::string& name,
      LogEntryType* value) {
    return LogEntry_LogEntryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes log_data = 3;
  bool has_log_data() const;
  void clear_log_data();
  static const int kLogDataFieldNumber = 3;
  const ::std::string& log_data() const;
  void set_log_data(const ::std::string& value);
  #if LANG_CXX11
  void set_log_data(::std::string&& value);
  #endif
  void set_log_data(const char* value);
  void set_log_data(const void* value, size_t size);
  ::std::string* mutable_log_data();
  ::std::string* release_log_data();
  void set_allocated_log_data(::std::string* log_data);

  // required int64 term = 2;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 2;
  ::google::protobuf::int64 term() const;
  void set_term(::google::protobuf::int64 value);

  // required .craft.LogEntry.LogEntryType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::craft::LogEntry_LogEntryType type() const;
  void set_type(::craft::LogEntry_LogEntryType value);

  // @@protoc_insertion_point(class_scope:craft.LogEntry)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_term();
  void clear_has_term();
  void set_has_log_data();
  void clear_has_log_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr log_data_;
  ::google::protobuf::int64 term_;
  int type_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsLogEntryImpl();
};
// -------------------------------------------------------------------

class AppendEntriesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.AppendEntriesRequest) */ {
 public:
  AppendEntriesRequest();
  virtual ~AppendEntriesRequest();

  AppendEntriesRequest(const AppendEntriesRequest& from);

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AppendEntriesRequest* other);
  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AppendEntriesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendEntriesRequest& from);
  void MergeFrom(const AppendEntriesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendEntriesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .craft.LogEntry entries = 7;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 7;
  const ::craft::LogEntry& entries(int index) const;
  ::craft::LogEntry* mutable_entries(int index);
  ::craft::LogEntry* add_entries();
  ::google::protobuf::RepeatedPtrField< ::craft::LogEntry >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::craft::LogEntry >&
      entries() const;

  // required string server_id = 1;
  bool has_server_id() const;
  void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  const ::std::string& server_id() const;
  void set_server_id(const ::std::string& value);
  #if LANG_CXX11
  void set_server_id(::std::string&& value);
  #endif
  void set_server_id(const char* value);
  void set_server_id(const char* value, size_t size);
  ::std::string* mutable_server_id();
  ::std::string* release_server_id();
  void set_allocated_server_id(::std::string* server_id);

  // required string peer_id = 2;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_id(::std::string&& value);
  #endif
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // required int64 term = 3;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 3;
  ::google::protobuf::int64 term() const;
  void set_term(::google::protobuf::int64 value);

  // required int64 prev_log_term = 4;
  bool has_prev_log_term() const;
  void clear_prev_log_term();
  static const int kPrevLogTermFieldNumber = 4;
  ::google::protobuf::int64 prev_log_term() const;
  void set_prev_log_term(::google::protobuf::int64 value);

  // required int64 prev_log_index = 5;
  bool has_prev_log_index() const;
  void clear_prev_log_index();
  static const int kPrevLogIndexFieldNumber = 5;
  ::google::protobuf::int64 prev_log_index() const;
  void set_prev_log_index(::google::protobuf::int64 value);

  // required int64 committed_index = 6;
  bool has_committed_index() const;
  void clear_committed_index();
  static const int kCommittedIndexFieldNumber = 6;
  ::google::protobuf::int64 committed_index() const;
  void set_committed_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:craft.AppendEntriesRequest)
 private:
  void set_has_server_id();
  void clear_has_server_id();
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_term();
  void clear_has_term();
  void set_has_prev_log_term();
  void clear_has_prev_log_term();
  void set_has_prev_log_index();
  void clear_has_prev_log_index();
  void set_has_committed_index();
  void clear_has_committed_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::craft::LogEntry > entries_;
  ::google::protobuf::internal::ArenaStringPtr server_id_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::int64 term_;
  ::google::protobuf::int64 prev_log_term_;
  ::google::protobuf::int64 prev_log_index_;
  ::google::protobuf::int64 committed_index_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsAppendEntriesRequestImpl();
};
// -------------------------------------------------------------------

class AppendEntriesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.AppendEntriesResponse) */ {
 public:
  AppendEntriesResponse();
  virtual ~AppendEntriesResponse();

  AppendEntriesResponse(const AppendEntriesResponse& from);

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AppendEntriesResponse* other);
  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AppendEntriesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendEntriesResponse& from);
  void MergeFrom(const AppendEntriesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendEntriesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int64 term() const;
  void set_term(::google::protobuf::int64 value);

  // optional int64 last_log_index = 3;
  bool has_last_log_index() const;
  void clear_last_log_index();
  static const int kLastLogIndexFieldNumber = 3;
  ::google::protobuf::int64 last_log_index() const;
  void set_last_log_index(::google::protobuf::int64 value);

  // required bool success = 2;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:craft.AppendEntriesResponse)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_success();
  void clear_has_success();
  void set_has_last_log_index();
  void clear_has_last_log_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 term_;
  ::google::protobuf::int64 last_log_index_;
  bool success_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsAppendEntriesResponseImpl();
};
// -------------------------------------------------------------------

class LockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.LockRequest) */ {
 public:
  LockRequest();
  virtual ~LockRequest();

  LockRequest(const LockRequest& from);

  inline LockRequest& operator=(const LockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockRequest(LockRequest&& from) noexcept
    : LockRequest() {
    *this = ::std::move(from);
  }

  inline LockRequest& operator=(LockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockRequest* internal_default_instance() {
    return reinterpret_cast<const LockRequest*>(
               &_LockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LockRequest* other);
  friend void swap(LockRequest& a, LockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockRequest& from);
  void MergeFrom(const LockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string owner = 2;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 2;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // required int64 time_ms = 3;
  bool has_time_ms() const;
  void clear_time_ms();
  static const int kTimeMsFieldNumber = 3;
  ::google::protobuf::int64 time_ms() const;
  void set_time_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:craft.LockRequest)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_owner();
  void clear_has_owner();
  void set_has_time_ms();
  void clear_has_time_ms();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::int64 time_ms_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsLockRequestImpl();
};
// -------------------------------------------------------------------

class LockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.LockResponse) */ {
 public:
  LockResponse();
  virtual ~LockResponse();

  LockResponse(const LockResponse& from);

  inline LockResponse& operator=(const LockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockResponse(LockResponse&& from) noexcept
    : LockResponse() {
    *this = ::std::move(from);
  }

  inline LockResponse& operator=(LockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockResponse* internal_default_instance() {
    return reinterpret_cast<const LockResponse*>(
               &_LockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LockResponse* other);
  friend void swap(LockResponse& a, LockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockResponse& from);
  void MergeFrom(const LockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string owner = 3;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 3;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // required bool acquired = 1;
  bool has_acquired() const;
  void clear_acquired();
  static const int kAcquiredFieldNumber = 1;
  bool acquired() const;
  void set_acquired(bool value);

  // @@protoc_insertion_point(class_scope:craft.LockResponse)
 private:
  void set_has_acquired();
  void clear_has_acquired();
  void set_has_key();
  void clear_has_key();
  void set_has_owner();
  void clear_has_owner();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  bool acquired_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsLockResponseImpl();
};
// -------------------------------------------------------------------

class UnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.UnlockRequest) */ {
 public:
  UnlockRequest();
  virtual ~UnlockRequest();

  UnlockRequest(const UnlockRequest& from);

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(UnlockRequest* other);
  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockRequest& from);
  void MergeFrom(const UnlockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string owner = 2;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 2;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // @@protoc_insertion_point(class_scope:craft.UnlockRequest)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_owner();
  void clear_has_owner();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsUnlockRequestImpl();
};
// -------------------------------------------------------------------

class UnlockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:craft.UnlockResponse) */ {
 public:
  UnlockResponse();
  virtual ~UnlockResponse();

  UnlockResponse(const UnlockResponse& from);

  inline UnlockResponse& operator=(const UnlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockResponse(UnlockResponse&& from) noexcept
    : UnlockResponse() {
    *this = ::std::move(from);
  }

  inline UnlockResponse& operator=(UnlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlockResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockResponse*>(
               &_UnlockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(UnlockResponse* other);
  friend void swap(UnlockResponse& a, UnlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockResponse& from);
  void MergeFrom(const UnlockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string owner = 3;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 3;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // required bool released = 1;
  bool has_released() const;
  void clear_released();
  static const int kReleasedFieldNumber = 1;
  bool released() const;
  void set_released(bool value);

  // @@protoc_insertion_point(class_scope:craft.UnlockResponse)
 private:
  void set_has_released();
  void clear_has_released();
  void set_has_key();
  void clear_has_key();
  void set_has_owner();
  void clear_has_owner();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  bool released_;
  friend struct ::protobuf_raft_2eproto::TableStruct;
  friend void ::protobuf_raft_2eproto::InitDefaultsUnlockResponseImpl();
};
// ===================================================================

class RpcRaftService_Stub;

class RpcRaftService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RpcRaftService() {};
 public:
  virtual ~RpcRaftService();

  typedef RpcRaftService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void RequestVote(::google::protobuf::RpcController* controller,
                       const ::craft::RequestVoteRequest* request,
                       ::craft::RequestVoteResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AppendEntries(::google::protobuf::RpcController* controller,
                       const ::craft::AppendEntriesRequest* request,
                       ::craft::AppendEntriesResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RpcRaftService);
};

class RpcRaftService_Stub : public RpcRaftService {
 public:
  RpcRaftService_Stub(::google::protobuf::RpcChannel* channel);
  RpcRaftService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RpcRaftService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RpcRaftService ------------------------------------------

  void RequestVote(::google::protobuf::RpcController* controller,
                       const ::craft::RequestVoteRequest* request,
                       ::craft::RequestVoteResponse* response,
                       ::google::protobuf::Closure* done);
  void AppendEntries(::google::protobuf::RpcController* controller,
                       const ::craft::AppendEntriesRequest* request,
                       ::craft::AppendEntriesResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RpcRaftService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestVoteRequest

// required string server_id = 1;
inline bool RequestVoteRequest::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestVoteRequest::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestVoteRequest::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestVoteRequest::clear_server_id() {
  server_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_id();
}
inline const ::std::string& RequestVoteRequest::server_id() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteRequest.server_id)
  return server_id_.GetNoArena();
}
inline void RequestVoteRequest::set_server_id(const ::std::string& value) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.RequestVoteRequest.server_id)
}
#if LANG_CXX11
inline void RequestVoteRequest::set_server_id(::std::string&& value) {
  set_has_server_id();
  server_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.RequestVoteRequest.server_id)
}
#endif
inline void RequestVoteRequest::set_server_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.RequestVoteRequest.server_id)
}
inline void RequestVoteRequest::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.RequestVoteRequest.server_id)
}
inline ::std::string* RequestVoteRequest::mutable_server_id() {
  set_has_server_id();
  // @@protoc_insertion_point(field_mutable:craft.RequestVoteRequest.server_id)
  return server_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestVoteRequest::release_server_id() {
  // @@protoc_insertion_point(field_release:craft.RequestVoteRequest.server_id)
  clear_has_server_id();
  return server_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestVoteRequest::set_allocated_server_id(::std::string* server_id) {
  if (server_id != NULL) {
    set_has_server_id();
  } else {
    clear_has_server_id();
  }
  server_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_id);
  // @@protoc_insertion_point(field_set_allocated:craft.RequestVoteRequest.server_id)
}

// required string peer_id = 2;
inline bool RequestVoteRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestVoteRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestVoteRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestVoteRequest::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_id();
}
inline const ::std::string& RequestVoteRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteRequest.peer_id)
  return peer_id_.GetNoArena();
}
inline void RequestVoteRequest::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.RequestVoteRequest.peer_id)
}
#if LANG_CXX11
inline void RequestVoteRequest::set_peer_id(::std::string&& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.RequestVoteRequest.peer_id)
}
#endif
inline void RequestVoteRequest::set_peer_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.RequestVoteRequest.peer_id)
}
inline void RequestVoteRequest::set_peer_id(const char* value, size_t size) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.RequestVoteRequest.peer_id)
}
inline ::std::string* RequestVoteRequest::mutable_peer_id() {
  set_has_peer_id();
  // @@protoc_insertion_point(field_mutable:craft.RequestVoteRequest.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestVoteRequest::release_peer_id() {
  // @@protoc_insertion_point(field_release:craft.RequestVoteRequest.peer_id)
  clear_has_peer_id();
  return peer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestVoteRequest::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    set_has_peer_id();
  } else {
    clear_has_peer_id();
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:craft.RequestVoteRequest.peer_id)
}

// required int64 term = 3;
inline bool RequestVoteRequest::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestVoteRequest::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestVoteRequest::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestVoteRequest::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteRequest.term)
  return term_;
}
inline void RequestVoteRequest::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:craft.RequestVoteRequest.term)
}

// required int64 last_log_term = 4;
inline bool RequestVoteRequest::has_last_log_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestVoteRequest::set_has_last_log_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestVoteRequest::clear_has_last_log_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestVoteRequest::clear_last_log_term() {
  last_log_term_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_term();
}
inline ::google::protobuf::int64 RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteRequest.last_log_term)
  return last_log_term_;
}
inline void RequestVoteRequest::set_last_log_term(::google::protobuf::int64 value) {
  set_has_last_log_term();
  last_log_term_ = value;
  // @@protoc_insertion_point(field_set:craft.RequestVoteRequest.last_log_term)
}

// required int64 last_log_index = 5;
inline bool RequestVoteRequest::has_last_log_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestVoteRequest::set_has_last_log_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestVoteRequest::clear_has_last_log_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestVoteRequest::clear_last_log_index() {
  last_log_index_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_index();
}
inline ::google::protobuf::int64 RequestVoteRequest::last_log_index() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteRequest.last_log_index)
  return last_log_index_;
}
inline void RequestVoteRequest::set_last_log_index(::google::protobuf::int64 value) {
  set_has_last_log_index();
  last_log_index_ = value;
  // @@protoc_insertion_point(field_set:craft.RequestVoteRequest.last_log_index)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// required int64 term = 1;
inline bool RequestVoteResponse::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestVoteResponse::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestVoteResponse::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestVoteResponse::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteResponse.term)
  return term_;
}
inline void RequestVoteResponse::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:craft.RequestVoteResponse.term)
}

// required bool granted = 2;
inline bool RequestVoteResponse::has_granted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestVoteResponse::set_has_granted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestVoteResponse::clear_has_granted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestVoteResponse::clear_granted() {
  granted_ = false;
  clear_has_granted();
}
inline bool RequestVoteResponse::granted() const {
  // @@protoc_insertion_point(field_get:craft.RequestVoteResponse.granted)
  return granted_;
}
inline void RequestVoteResponse::set_granted(bool value) {
  set_has_granted();
  granted_ = value;
  // @@protoc_insertion_point(field_set:craft.RequestVoteResponse.granted)
}

// -------------------------------------------------------------------

// LogEntry

// required .craft.LogEntry.LogEntryType type = 1;
inline bool LogEntry::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEntry::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::craft::LogEntry_LogEntryType LogEntry::type() const {
  // @@protoc_insertion_point(field_get:craft.LogEntry.type)
  return static_cast< ::craft::LogEntry_LogEntryType >(type_);
}
inline void LogEntry::set_type(::craft::LogEntry_LogEntryType value) {
  assert(::craft::LogEntry_LogEntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:craft.LogEntry.type)
}

// required int64 term = 2;
inline bool LogEntry::has_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEntry::set_has_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEntry::clear_has_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEntry::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 LogEntry::term() const {
  // @@protoc_insertion_point(field_get:craft.LogEntry.term)
  return term_;
}
inline void LogEntry::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:craft.LogEntry.term)
}

// optional bytes log_data = 3;
inline bool LogEntry::has_log_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntry::set_has_log_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntry::clear_has_log_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntry::clear_log_data() {
  log_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_log_data();
}
inline const ::std::string& LogEntry::log_data() const {
  // @@protoc_insertion_point(field_get:craft.LogEntry.log_data)
  return log_data_.GetNoArena();
}
inline void LogEntry::set_log_data(const ::std::string& value) {
  set_has_log_data();
  log_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.LogEntry.log_data)
}
#if LANG_CXX11
inline void LogEntry::set_log_data(::std::string&& value) {
  set_has_log_data();
  log_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.LogEntry.log_data)
}
#endif
inline void LogEntry::set_log_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_log_data();
  log_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.LogEntry.log_data)
}
inline void LogEntry::set_log_data(const void* value, size_t size) {
  set_has_log_data();
  log_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.LogEntry.log_data)
}
inline ::std::string* LogEntry::mutable_log_data() {
  set_has_log_data();
  // @@protoc_insertion_point(field_mutable:craft.LogEntry.log_data)
  return log_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_log_data() {
  // @@protoc_insertion_point(field_release:craft.LogEntry.log_data)
  clear_has_log_data();
  return log_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_log_data(::std::string* log_data) {
  if (log_data != NULL) {
    set_has_log_data();
  } else {
    clear_has_log_data();
  }
  log_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_data);
  // @@protoc_insertion_point(field_set_allocated:craft.LogEntry.log_data)
}

// -------------------------------------------------------------------

// AppendEntriesRequest

// required string server_id = 1;
inline bool AppendEntriesRequest::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntriesRequest::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntriesRequest::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntriesRequest::clear_server_id() {
  server_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_id();
}
inline const ::std::string& AppendEntriesRequest::server_id() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.server_id)
  return server_id_.GetNoArena();
}
inline void AppendEntriesRequest::set_server_id(const ::std::string& value) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.server_id)
}
#if LANG_CXX11
inline void AppendEntriesRequest::set_server_id(::std::string&& value) {
  set_has_server_id();
  server_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.AppendEntriesRequest.server_id)
}
#endif
inline void AppendEntriesRequest::set_server_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.AppendEntriesRequest.server_id)
}
inline void AppendEntriesRequest::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.AppendEntriesRequest.server_id)
}
inline ::std::string* AppendEntriesRequest::mutable_server_id() {
  set_has_server_id();
  // @@protoc_insertion_point(field_mutable:craft.AppendEntriesRequest.server_id)
  return server_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppendEntriesRequest::release_server_id() {
  // @@protoc_insertion_point(field_release:craft.AppendEntriesRequest.server_id)
  clear_has_server_id();
  return server_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppendEntriesRequest::set_allocated_server_id(::std::string* server_id) {
  if (server_id != NULL) {
    set_has_server_id();
  } else {
    clear_has_server_id();
  }
  server_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_id);
  // @@protoc_insertion_point(field_set_allocated:craft.AppendEntriesRequest.server_id)
}

// required string peer_id = 2;
inline bool AppendEntriesRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendEntriesRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendEntriesRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendEntriesRequest::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_id();
}
inline const ::std::string& AppendEntriesRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.peer_id)
  return peer_id_.GetNoArena();
}
inline void AppendEntriesRequest::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.peer_id)
}
#if LANG_CXX11
inline void AppendEntriesRequest::set_peer_id(::std::string&& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.AppendEntriesRequest.peer_id)
}
#endif
inline void AppendEntriesRequest::set_peer_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.AppendEntriesRequest.peer_id)
}
inline void AppendEntriesRequest::set_peer_id(const char* value, size_t size) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.AppendEntriesRequest.peer_id)
}
inline ::std::string* AppendEntriesRequest::mutable_peer_id() {
  set_has_peer_id();
  // @@protoc_insertion_point(field_mutable:craft.AppendEntriesRequest.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppendEntriesRequest::release_peer_id() {
  // @@protoc_insertion_point(field_release:craft.AppendEntriesRequest.peer_id)
  clear_has_peer_id();
  return peer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppendEntriesRequest::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    set_has_peer_id();
  } else {
    clear_has_peer_id();
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:craft.AppendEntriesRequest.peer_id)
}

// required int64 term = 3;
inline bool AppendEntriesRequest::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppendEntriesRequest::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppendEntriesRequest::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppendEntriesRequest::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.term)
  return term_;
}
inline void AppendEntriesRequest::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.term)
}

// required int64 prev_log_term = 4;
inline bool AppendEntriesRequest::has_prev_log_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppendEntriesRequest::set_has_prev_log_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppendEntriesRequest::clear_has_prev_log_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppendEntriesRequest::clear_prev_log_term() {
  prev_log_term_ = GOOGLE_LONGLONG(0);
  clear_has_prev_log_term();
}
inline ::google::protobuf::int64 AppendEntriesRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.prev_log_term)
  return prev_log_term_;
}
inline void AppendEntriesRequest::set_prev_log_term(::google::protobuf::int64 value) {
  set_has_prev_log_term();
  prev_log_term_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.prev_log_term)
}

// required int64 prev_log_index = 5;
inline bool AppendEntriesRequest::has_prev_log_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppendEntriesRequest::set_has_prev_log_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppendEntriesRequest::clear_has_prev_log_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppendEntriesRequest::clear_prev_log_index() {
  prev_log_index_ = GOOGLE_LONGLONG(0);
  clear_has_prev_log_index();
}
inline ::google::protobuf::int64 AppendEntriesRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.prev_log_index)
  return prev_log_index_;
}
inline void AppendEntriesRequest::set_prev_log_index(::google::protobuf::int64 value) {
  set_has_prev_log_index();
  prev_log_index_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.prev_log_index)
}

// required int64 committed_index = 6;
inline bool AppendEntriesRequest::has_committed_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppendEntriesRequest::set_has_committed_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppendEntriesRequest::clear_has_committed_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppendEntriesRequest::clear_committed_index() {
  committed_index_ = GOOGLE_LONGLONG(0);
  clear_has_committed_index();
}
inline ::google::protobuf::int64 AppendEntriesRequest::committed_index() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.committed_index)
  return committed_index_;
}
inline void AppendEntriesRequest::set_committed_index(::google::protobuf::int64 value) {
  set_has_committed_index();
  committed_index_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesRequest.committed_index)
}

// repeated .craft.LogEntry entries = 7;
inline int AppendEntriesRequest::entries_size() const {
  return entries_.size();
}
inline void AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline const ::craft::LogEntry& AppendEntriesRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesRequest.entries)
  return entries_.Get(index);
}
inline ::craft::LogEntry* AppendEntriesRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:craft.AppendEntriesRequest.entries)
  return entries_.Mutable(index);
}
inline ::craft::LogEntry* AppendEntriesRequest::add_entries() {
  // @@protoc_insertion_point(field_add:craft.AppendEntriesRequest.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::craft::LogEntry >*
AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:craft.AppendEntriesRequest.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::craft::LogEntry >&
AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_list:craft.AppendEntriesRequest.entries)
  return entries_;
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// required int64 term = 1;
inline bool AppendEntriesResponse::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntriesResponse::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntriesResponse::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntriesResponse::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 AppendEntriesResponse::term() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesResponse.term)
  return term_;
}
inline void AppendEntriesResponse::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesResponse.term)
}

// required bool success = 2;
inline bool AppendEntriesResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppendEntriesResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppendEntriesResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppendEntriesResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesResponse.success)
  return success_;
}
inline void AppendEntriesResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesResponse.success)
}

// optional int64 last_log_index = 3;
inline bool AppendEntriesResponse::has_last_log_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendEntriesResponse::set_has_last_log_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendEntriesResponse::clear_has_last_log_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendEntriesResponse::clear_last_log_index() {
  last_log_index_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_index();
}
inline ::google::protobuf::int64 AppendEntriesResponse::last_log_index() const {
  // @@protoc_insertion_point(field_get:craft.AppendEntriesResponse.last_log_index)
  return last_log_index_;
}
inline void AppendEntriesResponse::set_last_log_index(::google::protobuf::int64 value) {
  set_has_last_log_index();
  last_log_index_ = value;
  // @@protoc_insertion_point(field_set:craft.AppendEntriesResponse.last_log_index)
}

// -------------------------------------------------------------------

// LockRequest

// required string key = 1;
inline bool LockRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LockRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LockRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& LockRequest::key() const {
  // @@protoc_insertion_point(field_get:craft.LockRequest.key)
  return key_.GetNoArena();
}
inline void LockRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.LockRequest.key)
}
#if LANG_CXX11
inline void LockRequest::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.LockRequest.key)
}
#endif
inline void LockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.LockRequest.key)
}
inline void LockRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.LockRequest.key)
}
inline ::std::string* LockRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:craft.LockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockRequest::release_key() {
  // @@protoc_insertion_point(field_release:craft.LockRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:craft.LockRequest.key)
}

// required string owner = 2;
inline bool LockRequest::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LockRequest::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LockRequest::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LockRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& LockRequest::owner() const {
  // @@protoc_insertion_point(field_get:craft.LockRequest.owner)
  return owner_.GetNoArena();
}
inline void LockRequest::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.LockRequest.owner)
}
#if LANG_CXX11
inline void LockRequest::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.LockRequest.owner)
}
#endif
inline void LockRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.LockRequest.owner)
}
inline void LockRequest::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.LockRequest.owner)
}
inline ::std::string* LockRequest::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:craft.LockRequest.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockRequest::release_owner() {
  // @@protoc_insertion_point(field_release:craft.LockRequest.owner)
  clear_has_owner();
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockRequest::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:craft.LockRequest.owner)
}

// required int64 time_ms = 3;
inline bool LockRequest::has_time_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LockRequest::set_has_time_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LockRequest::clear_has_time_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LockRequest::clear_time_ms() {
  time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_time_ms();
}
inline ::google::protobuf::int64 LockRequest::time_ms() const {
  // @@protoc_insertion_point(field_get:craft.LockRequest.time_ms)
  return time_ms_;
}
inline void LockRequest::set_time_ms(::google::protobuf::int64 value) {
  set_has_time_ms();
  time_ms_ = value;
  // @@protoc_insertion_point(field_set:craft.LockRequest.time_ms)
}

// -------------------------------------------------------------------

// LockResponse

// required bool acquired = 1;
inline bool LockResponse::has_acquired() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LockResponse::set_has_acquired() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LockResponse::clear_has_acquired() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LockResponse::clear_acquired() {
  acquired_ = false;
  clear_has_acquired();
}
inline bool LockResponse::acquired() const {
  // @@protoc_insertion_point(field_get:craft.LockResponse.acquired)
  return acquired_;
}
inline void LockResponse::set_acquired(bool value) {
  set_has_acquired();
  acquired_ = value;
  // @@protoc_insertion_point(field_set:craft.LockResponse.acquired)
}

// required string key = 2;
inline bool LockResponse::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LockResponse::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LockResponse::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LockResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& LockResponse::key() const {
  // @@protoc_insertion_point(field_get:craft.LockResponse.key)
  return key_.GetNoArena();
}
inline void LockResponse::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.LockResponse.key)
}
#if LANG_CXX11
inline void LockResponse::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.LockResponse.key)
}
#endif
inline void LockResponse::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.LockResponse.key)
}
inline void LockResponse::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.LockResponse.key)
}
inline ::std::string* LockResponse::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:craft.LockResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_key() {
  // @@protoc_insertion_point(field_release:craft.LockResponse.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:craft.LockResponse.key)
}

// required string owner = 3;
inline bool LockResponse::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LockResponse::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LockResponse::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LockResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& LockResponse::owner() const {
  // @@protoc_insertion_point(field_get:craft.LockResponse.owner)
  return owner_.GetNoArena();
}
inline void LockResponse::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.LockResponse.owner)
}
#if LANG_CXX11
inline void LockResponse::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.LockResponse.owner)
}
#endif
inline void LockResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.LockResponse.owner)
}
inline void LockResponse::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.LockResponse.owner)
}
inline ::std::string* LockResponse::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:craft.LockResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_owner() {
  // @@protoc_insertion_point(field_release:craft.LockResponse.owner)
  clear_has_owner();
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:craft.LockResponse.owner)
}

// -------------------------------------------------------------------

// UnlockRequest

// required string key = 1;
inline bool UnlockRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& UnlockRequest::key() const {
  // @@protoc_insertion_point(field_get:craft.UnlockRequest.key)
  return key_.GetNoArena();
}
inline void UnlockRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.UnlockRequest.key)
}
#if LANG_CXX11
inline void UnlockRequest::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.UnlockRequest.key)
}
#endif
inline void UnlockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.UnlockRequest.key)
}
inline void UnlockRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.UnlockRequest.key)
}
inline ::std::string* UnlockRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:craft.UnlockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_key() {
  // @@protoc_insertion_point(field_release:craft.UnlockRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:craft.UnlockRequest.key)
}

// required string owner = 2;
inline bool UnlockRequest::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnlockRequest::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnlockRequest::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnlockRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& UnlockRequest::owner() const {
  // @@protoc_insertion_point(field_get:craft.UnlockRequest.owner)
  return owner_.GetNoArena();
}
inline void UnlockRequest::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.UnlockRequest.owner)
}
#if LANG_CXX11
inline void UnlockRequest::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.UnlockRequest.owner)
}
#endif
inline void UnlockRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.UnlockRequest.owner)
}
inline void UnlockRequest::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.UnlockRequest.owner)
}
inline ::std::string* UnlockRequest::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:craft.UnlockRequest.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_owner() {
  // @@protoc_insertion_point(field_release:craft.UnlockRequest.owner)
  clear_has_owner();
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:craft.UnlockRequest.owner)
}

// -------------------------------------------------------------------

// UnlockResponse

// required bool released = 1;
inline bool UnlockResponse::has_released() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnlockResponse::set_has_released() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnlockResponse::clear_has_released() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnlockResponse::clear_released() {
  released_ = false;
  clear_has_released();
}
inline bool UnlockResponse::released() const {
  // @@protoc_insertion_point(field_get:craft.UnlockResponse.released)
  return released_;
}
inline void UnlockResponse::set_released(bool value) {
  set_has_released();
  released_ = value;
  // @@protoc_insertion_point(field_set:craft.UnlockResponse.released)
}

// required string key = 2;
inline bool UnlockResponse::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockResponse::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockResponse::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& UnlockResponse::key() const {
  // @@protoc_insertion_point(field_get:craft.UnlockResponse.key)
  return key_.GetNoArena();
}
inline void UnlockResponse::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.UnlockResponse.key)
}
#if LANG_CXX11
inline void UnlockResponse::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.UnlockResponse.key)
}
#endif
inline void UnlockResponse::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.UnlockResponse.key)
}
inline void UnlockResponse::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.UnlockResponse.key)
}
inline ::std::string* UnlockResponse::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:craft.UnlockResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockResponse::release_key() {
  // @@protoc_insertion_point(field_release:craft.UnlockResponse.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:craft.UnlockResponse.key)
}

// required string owner = 3;
inline bool UnlockResponse::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnlockResponse::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnlockResponse::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnlockResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& UnlockResponse::owner() const {
  // @@protoc_insertion_point(field_get:craft.UnlockResponse.owner)
  return owner_.GetNoArena();
}
inline void UnlockResponse::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:craft.UnlockResponse.owner)
}
#if LANG_CXX11
inline void UnlockResponse::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:craft.UnlockResponse.owner)
}
#endif
inline void UnlockResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:craft.UnlockResponse.owner)
}
inline void UnlockResponse::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:craft.UnlockResponse.owner)
}
inline ::std::string* UnlockResponse::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:craft.UnlockResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockResponse::release_owner() {
  // @@protoc_insertion_point(field_release:craft.UnlockResponse.owner)
  clear_has_owner();
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:craft.UnlockResponse.owner)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace craft

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::craft::LogEntry_LogEntryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::craft::LogEntry_LogEntryType>() {
  return ::craft::LogEntry_LogEntryType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_raft_2eproto__INCLUDED
